1、课程计划
    内容：C++、Qt
    时间：3周+1周左右
    目标：熟悉语言本身、标准库、Qt库

2、C++简介
    历史
        1979年，本贾尼-斯特劳斯特卢普 在C语言的基础设计了一门新的编程语言，最初始称为 C with Class
        1984年，正式命名为 C plus plus（C++） 
        C++兼容C语言，现在一般称C和C++为一个系列的语言： C/C++
    领域
        C++应用于 系统与系统软件、嵌入式、图形界面应用、后端(服务端)、游戏开发、科学计算等

    标准(版本)
        1998年  发布了第一个世界标准：  C++98/03
        2011年  发布了第二个世界标准：  C++11
        如果在代码中使用了C++11及以上标准中的语言特性，在(交叉)编译时，可能需要加上编译选项: -std=c++11
        例： 
        arm-linux-g++ xxx.cpp -std=c++11



    编译器
        在Ubuntu中，使用编译器 g++ , 一般需要自行安装：
            sudo apt install g++ 

        在ARM-LINUX中，使用 arm-linux-g++, 需要自己配置，配置过程与arm-linux-gcc类似。
        查看交叉编译器版本：
            arm-linux-g++ -v

        在windows中，使用微软的集成开发环境(IDE): visual studio 20xx


3、第一个C++程序 
    #include <iostream>
    int main(int argc, char const *argv[])
    {
        std::cout << "hello world" << std::endl;
        return 0;
    }
    说明：
    1、标准C++中的头文件都没有扩展名
        如果是使用的标准C或操作系统提供的头文件，使用方式与C相同
        如果是自定义的头文件，则还是要写扩展名，可以是 .h ，也可以是 .hpp
        iostream 是用于输入输出相关功能的头文件

    2、std 是C++标准库中一个作用域的名字，其中存放了标准C++库中所有的名字
        这种用来存放名字的作用域，称为 namespace(命名空间、名字空间)

    
    3、:: 称为 作用域运算符，用于访问指定作用域中的某个名字

    4、标准IO流对象
        cin     标准输入流      (stdin)
        cout    标准输出流      (stdout)
        cerr    标准错误流      (stderr)

    5、输入输出运算符
        <<  输出运算符 ， 结合 cout 或 cerr 使用 
        >>  输入运算符 ， 结合 cin 使用

    6、endl => end line 相当于 "\n"
    



4、namespace(命名空间)
    namespace 是一种作用域，是对全局作用域的切分(本质上是全局的)，用于存放各种名字，如 变量名、函数名、类型名、对象名、命名空间的名称等
    namespace 适用于大型软件的开发，用于解决 软件开发中存在的 名字冲突的 问题。
    同时也表示一个逻辑单元，使得在用户看来，它们是一个整体。

    定义：
    namespace 命名空间名称
    {
        定义变量
        定义函数
        定义类型
        定义命名空间
        ...
    }
    使用方式：
    1、显示限定
        命名空间名称::成员名称
        例： 
        std::cout 
        std::endl

    2、using 声明
        using 命名空间名称::成员名称;
        例： 
        using std::cout;
        using std::endl;
        cout << "hello";
        cout << "world";
        cout << endl;

    3、using 指示
        using namespace 命名空间名称;
        例：
        using namespace std;


    4、全局作用域也可以理解为一个命名空间，但它没有名字，一般可称为 匿名名字空间
        如果需要显示的使用 全局作用域中的 某个名字，方式如下：
            ::全局标识符
        例： 
            ::close(fd); // 操作系统提供的接口都是全局的


    using关键字的说明：
        using不仅能用在命名空间的使用上，还能用于定义类型别名(需要C++11)
        使用using给类型起别名的一般格式如下：
        using 类型别名=类型名;
        例： 
        using uchar = unsigned char;
        using size_t = unsigned long;


5、布尔类型 bool
    bool类型是C++的基础类型之一，用于表示逻辑概念
        零为假，非零即为真
    bool类型只有两种值：真和假
    在C++中，使用 true 表示真，用 false 表示假
    sizeof(bool) == 1

    主要用于两种场合：
    1、条件判断 
    2、函数返回

    例： 
        给定一个字符串，输出其中的数字字符
        "hello 309"

        把判断某个字符是否是数字的功能包装成函数
        bool isdigit(char c);

        bool类型的使用示例：
        bool ok = isdigit('a');
        if (ok)
        {
            // 判断ok为真
        }
        if (!ok)
        {
            // 判断ok为假
        }

    练习：
        给定一个字符串，把其中的小写字母转换成大写字母，再输出
        "hello 309"
        => "HELLO 309"



6、引用 reference
    引用是一个已存在对象的别名。
    语法格式：
        类型名 & 引用名 = 对象名;
    
    例： 
    int a = 100;
    int & r = a; // r就是a, a就是r

    说明： 
    1、引用在定义时，必须初始化
    2、引用一旦绑定成功(初始化完成), 就再也不能成为其他对象的别名了
    3、对引用进行的任何操作，都是在操作与之绑定的对象
    4、引用是别名，不是对象(对象需要占用空间，引用不需要)
    
    引用的主要用途：
        函数参数
        函数返回 （不能返回当前函数的局部变量的引用）
        

    引用分类：
    1、常规引用(左值引用)
        只能绑定到左值的引用，左值引用可读可写。
        int a = 100;
        int & r = a;    // r就是左值引用，只能绑定到左值
        int & r = 100;  // 100是右值，出错
    2、const 引用(常引用)
        既能绑定到左值，也能绑定到右值，通过const引用只能读取对象的值
        const int& r = a;   // 绑定到左值
        const int& r = 100; // 绑定到右值

    3、右值引用
        只能绑定到右值的引用，语法格式如下：
        类型名 && 引用名 = 右值;
        int&& r = 100;
        注：右值引用是C++11为了对象的移动而引入的。


    练习： 
        实现算法swap， 以交换两个整型变量的值
        写两个版本：指针和引用

   

7、函数重载 function overload
    所谓函数重载，指的是在相同的作用域中， 定义函数名相同，但参数列表不相同的函数
    
    例： 
    int sum(int a, int b);
    double sum(double a, double b);

    当调用重载函数时，编译器会根据实参推导其类型，自动匹配相应的函数
    如果实参的类型与形参的不完全一致，编译器会尝试自动做隐式类型转换
    sum(1, 2);  => int sum(int a, int b);
    sum(1.1, 2.2); => double sum(double a, double b);

    sum(1, 2.2); => 错误

    说明： 
    1、函数重载中参数列表不相同的具体情况
        要么 个数不同
            int sum(int a, int b);
            int sum(int a, int b, int c);
        要么 类型不同
            int sum(int a, int b);
            double sum(double a, double b);
        要么 顺序不同
            int sum(int a, double b);
            int sum(double a, int b);

    2、函数重载与返回类型无关。



    作业：
    1、编写函数实现
        max/min

    2、引用与指针有什么区别？

    3、int/float/bool/指针 如何与零值比较？

    4、如何使用cout输出整数的16进制？

    5、复习下Linux中的文件操作，如显示屏与位图显示




8、默认参数 default argument
    在C++中，声明函数时，如果函数有形参，则允许在声明时给形参设置一个默认值
    例： 
    void foo(int x=0);
    foo();  // x = 0
    foo(1); // x = 1
    当调用这种带有默认值的函数时，可以不给有默认值的参数传参，它会自动使用声明时设置的默认值
    如果给这种参数传递实参，则使用用户传递的实参，而不再使用默认值。
    一般格式：
    返回类型 函数名(类型名 参数=默认值, ...);

    注： 
    1、如果函数声明与定义分开，则参数的默认值只能写在声明处
    2、如果函数有多个形参，给其中某个参数设置了默认值，则它右边所有的形参都必须设置默认值


    练习： 
    写一个函数，实现一个整数的n次方
    pow(3); => 9
    pow(2,3);=> 8



9、内联函数 inline
    用关键字 inline 说明的函数，称为内联函数

    在C++中，内联函数是一种优化手段，用于减少函数调用的开销，以提高程序的执行效率。
    当调用这种被说明为内联的函数时，编译器在编译阶段 尝试 把函数体 直接复制到 函数调用点，而不是进行常规的函数调用(传参、跳转、返回等)
    这样做可以消除函数调用的开销，但是可能 会增加最后生成的可执行文件的大小。
    一般格式：
    inline 返回类型 函数名(参数列表)
    {
        函数体
    }

    说明： 
        函数即使被声明为内联函数，但最终能否真正的内联，处决于编译器。
        函数体简单(没有无限循环、没有递归等)，需要频繁调用的函数，才适合写成内联函数。
        在struct和class中定义的函数，默认就是内联函数。
    


10、关键字 extern "C"
    extern "C" 称为链接指示，用于提示C++编译器按照C语言的规则去编译和链接指定的函数。

    C++编译器在编译函数时，会对函数名进行修改(主函数例外)：
        给函数名加前缀和后缀(前缀一般表示作用域，后缀表示的是参数列表)
    例： 
        int sum(int a, int b);
        以上函数被C++编译器编译后，生成的函数名为 _Z3sumii

    但是，C语言编译，不会修改函数名。
    所以，当在C++中，调用Ｃ库中的函数时，就可能会出现 由于函数名不匹配 而产生的链接错误。
    解决方案：
        使用关键字 extern "C" 对C库中的函数进行说明。

    典型示例：
    #ifdef __cplusplus
    extern "C"
    {
    #endif

        int sum(int a, int b);

        void foo();
        
    #ifdef __cplusplus
    }
    #endif

    注： 
        __cplusplus 是C++编译器内置的宏
        extern "C"修饰的函数，能否重载？



1、面向对象和面向过程
    C++是一门面向对象的编程语言
    面向对象和面向过程是解决问题的两种方法(思想)


    面向过程 
        面向过程主要关注解决问题的步骤与过程，通过一系列函数(过程)进行操作与处理
        将程序看作是一系列的步骤，通过顺序、选择或循环等基本的控制结构来组织程序代码
        面向过程的程序通常将数据和相关的操作分离，以函数为中心进行程序设计。
    例：在开发板的显示屏上绘制一个矩形
        1、打开屏幕文件
        2、内存映射
        3、绘制
        4、解除映射
        5、关闭文件


    面向对象 
        面向对象将程序看作是 一系列的对象，这些对象包含数据和相关的操作。
        对象之间通过传递消息进行交互协作。
        面向对象强调的是数据与相关操作的 封装性，通过类与对象进行程序设计。
    例：在开发板的显示屏上绘制一个矩形
        1、定义屏幕类型，描述的是屏幕的属性和行为   
        2、实例化一个屏幕对象
        3、定义矩形类型，描述矩形的属性和行为
        4、实例化一个矩形对象
        5、给矩形发消息，绘制到指定的屏幕对象上

    面向对象的三大基本特征：
    封装 
    继承
    多态

2、面向对象编程 (OOP)
    类(class)
        类就是类型，是自定义的数据类型
        用于描述实现世界中那些复杂的概念，描述同一类事物的共同的属性和行为。
        例： 
            学生
                属性：学号、姓名、年龄、性别、学校、专业...
                行为：吃、喝、学习、说话、走路...
        在程序中，一般用数据表示属性，用函数表示行为
        class的一般形式：
        class 类名 
        {
        访问权限符：
            属性(成员变量) 
            行为(成员函数/方法/接口)
        };

        访问权限符(访问修饰符、访问控制符)：
        public      公开、公有的，表示对外公开、外界可直接访问
        private     私有、隐藏的，表示对外不可见(不可直接访问)，但对其朋友(friend)例外
        protected   (受)保护的、隐藏的，表示对外不可见(不可直接访问)，但对其朋友(friend)与后代例外

    注：
        在定义单个类型时，使用关键字class,也可以使用struct
        对于class来说，如果成员缺省访问修饰符，则默认为private
        对于struct来说，如果成员缺省访问修饰符，则默认为public




    对象(object)
        从面向对象的角度，一切皆对象
        从编程的角度来说，类 类型的变量，就是对象

        用 类 类型 定义变量，称为实例化对象
        一般格式：
        类名 对象名;
        例： 
        Student s;

        给对象发消息：
        对象名.消息名();
        例： 
        s.sutdy();


3、类的组织形式
    标准C++类，一般由两部分组成：
    头文件(.h/.hpp), 写类的声明
    源文件(.cpp)， 写类的定义
    例： 
    头文件 point.hpp
    #ifndef POINT_HPP
    #define POINT_HPP

    class Point
    {
    public:
        // access function
        int getX() const;
        void setX(int x);
        ...
    private:
        int _x; 
        int _y;
    };

    #endif

    源文件 point.cpp
    #include "point.hpp"
    int Point::getX() const
    {
        return _x;
    }
    void Point::setX(int x)
    {
        _x = x;
    }    
    说明：
        在类外定义成员函数时，必须指明作用域。

    测试文件：test_point.cpp 
    #include "point.hpp"

    int main(int argc, char const *argv[])
    {
        Point pos;
        pos.setX(100);
        ...
        return 0;
    }    


4、只读成员函数
    对于对象的属性，一般会设计一组函数来进行访问(access function)    
    一般用getxxx这种函数名表示读取属性的值，用setxxx表示修改属性的值
    如果某些成员函数确实只读取成员变量的值，不会修改对象的状态，则可以使用关键字const加以说明。
    一般如下：
    class 类名 
    {
    public:
        返回类型 函数名(参数列表) const; // 声明
    };
    返回类型 类名::函数名(参数列表) const // 定义
    {
        函数体
    }

    注：通过const引用或指向const的指针，只能调用对象的只读成员函数。



    作业：
        Screen s;
        Rect r;
        ...
        r.draw(s);    

    class Screen
    {
    public:
        void init();
        void draw_point(int x, int y, int color);
        void draw_point(Point pos, Color color);
        void uninit();
    private:
        ...
    };

    class Rect 
    {
    public:
        ...
        void draw(Screen& s)
        {
            for ()
            {
                for ()
                {
                    s.draw_point(...);
                }
            }
        }
    private:
        ...
    };



5、构造函数
    功能：构造函数是一种特殊的成员函数，用于初始化对象的成员
    特点：
        构造函数名称与类名相同
        构造函数没有返回类型，只有函数名、参数列表及函数体
        在实例化对象时，自动调用构造函数。实例化一个对象，一定会调用且只调用一次构造函数。
        如果类中没有显式的定义构造函数，编译器会自动合成一个构造函数。

    例： 
    class Demo 
    {
    public:
        Demo() {}   // 默认构造函数
        Demo(int x) {} // 带参数的构造函数
    };

    Demo d1; // 自动调用 Demo()
    Demo d2(100); // 自动调用 Demo(int)

    说明： 
    1、默认构造函数(不提供任何实参就能调用的构造函数)，有两种情况
        a.没有参数
        b.有参数，但全部有默认值

    2、如果在实例化对象时，需要传递参数进行初始化，常见形式：
        类名 对象名(实参列表);
        类名 对象名{实参列表}; // C++11
        例： 
        Demo d1(100);
        Demo d2{200};

        但是，如果在实例化对象时，不提供实参，进行默认初始化，则不能写圆括号
        例： 
        Demo d3; // 不写括号，调用默认构造函数
        Demo d4(); // 这是函数声明，不是实例化对象
        但可以用大括号
        例： 
        Demo d5{}; // 这是实例化对象，要求C++11


    3、实例化对象时，会自动调用构造函数，反之，调用构造函数，一定会实例化一个对象。
    例： 
        Demo d6; // 自动调用默认构造函数
        Demo d7(300); // 自动调用Demo(int)

        直接显示的调用构造函数，会构造一个没有名字的对象，生命周期短暂，一般称为匿名(临时)对象
        Demo(400); 得到一个临时对象，主要用于传参。
        例： 
        void print_demo(const Demo& d);
        print_demo(d1); // 先创建对象d1, 再传参
        print_demo(Demo(800));// 在传参时构造一个临时对象，传递给函数


6、构造函数初始化列表
    所谓构造函数成员初始化列表，指在定义构造函数时，在参数列表的后面、函数体的大括号之前，用一个冒号引导，进行成员变量的初始化，
    一般如下：
    构造函数(参数列表):成员变量1(初值1), ..., 成员变量n(初值n)
    {
        函数体
    }
    有三种情况，必须使用成员初始化列表：
    1、成员是引用
    2、引用是常量
    3、成员对象没有默认构造函数
    例： 
    class Demo
    {
    public:
        Demo(int x, int y): _x(x), _y(y), _z(0), _r(_x), _o(x) {}
    private:
        int _x;
        int _y;
        const int _z; // 成员是常量
        int& _r;    // 成员是引用
        Other _o;   // 成员对象没有默认构造函数
    };    

    一般建议使用成员初始化列表：
    1、代码理简洁
    2、效率更高



7、析构函数    
    功能：析构函数也是一种特殊的成员函数，用于释放对象所占用的系统资源。
    特点： 
        析构函数的名字由 ~加上类名组成： ~类名 
        析构函数没有返回类型，只有函数名、参数列表及函数体，且参数列表必须为空。
        当对象销毁时，自动调用。
        如果类中没有显式的定义析构函数，编译器会自动合成一个析构函数。

    例： 
    class Demo 
    {
    public:
        Demo() {}       // 默认构造函数
        Demo(int x) {}  // 带参数的构造函数
        ~Demo() {}      // 析构函数 
    };

    注： 
    只有当对象占用了系统资源，才需要自己定义析构函数。



8、this指针
    当用一个类 实例化一个对象，对象具体存在，占用存储空间(空类对象也会占用一个字节)
    从理论上来说，一个对象由两部分组成：
        属性(数据) 
        行为(函数)

    但从实现的角度来看，每个对象有自己的存储空间，但存储空间中只存储了对象自己的成员变量(数据)
    
    成员函数不占用对象的存储空间，单独存放于 代码段，只保存一份，由所有同类型的对象 所共用。

    那么，相同的成员函数，如何区分不同的对象？
        在C++中，每个非静态的成员函数，都有一个隐藏参数，名为this
        当用一个对象调用这种函数时，编译器会自动把该对象的地址传递给这个隐藏的this指针
        当需要访问对象的成员时，就通过这个this指针进行访问。
        一般如下：
        class 类名 
        {
        public:
            [返回类型] 函数名(类名* const this, ...);
        };
        说明： 
            this指针位于参数列表的最前面，它的定义与传参，都由编译器自动完成。
            在程序中，用户可以直接使用this或*this, 但不可改变this的指向。
            如果该函数是只读的成员函数，则只读成员函数后面的const就是用来修饰这个this指针的
                此时，this的形式为： const 类名* const this 
                当通过this访问对象的成员时，就不能修改对象成员的值了。




9、静态成员
    用关键字 static 说明的成员，称为静态成员：
    静态成员变量
    静态成员函数

    静态成员变量
        用于同类型对象之间的数据共享
        不属于对象，而是属于类型，它不占用对象的存储空间
        静态成员变量必须在类外单独初始化

    静态成员函数
        不属于对象，而是属于类型
        静态成员函数有两种调用方式：
        1、通过对象调用
            对象名.静态成员函数(参数列表);
        2、通过类名调用
            类名::静态成员函数(参数列表);

        静态成员函数中没有this指针
            静态成员函数不能访问非静态的成员变量
            静态成员函数也不能设置为 只读成员函数。



    作业： 
    写一个日期类型Date, 实现获取当前日期的功能

    class Date 
    {
    public:
        Date(int y, int m, int d);
        static Date currentDate();
        ...
    private:
        int _y;
        int _m;
        int _d;
    };

    Date d1(2000,1,1);

    Date today = Date::currentDate();

    提示： time, localtime


    画圆、画BMP图片

    Circle c(10, Point(100,100));
    c.draw(s);


    Bitmap bmp("./1.bmp");
    bmp.draw(s);



10、动态内存管理
    C++中，对象所占用的内存，分三种：
    局部对象                栈区(.stack)
    全局对象/静态对象        静态存储区(.bss .data)
    动态对象                堆区(.heap) 

    C语言中，使用标准库函数 malloc/free 系列函数 来管理动态内存
    在C++中，如果处理的是基础类型，还是可以使用 malloc/free, 但如果处理的是类类型的对象，则不再建议使用
    在C++中，使用 new/delete 运算符(关键字) 来管理动态内存
        new 用来分配(申请)动态内存，delete用来释放动态内存。

    语法格式：
        类型名 * 指针名 = new 类型名;           // 动态创建单个对象，默认初始化
        类型名 * 指针名 = new 类型名(初值列表); // 动态创建单个对象，指定初值进行初始化
        类型名 * 指针名 = new 类型名{初值列表}; // 动态创建单个对象，指定初值进行初始化，C++11
        类型名 * 指针名 = new 类型名[元素个数]; // 动态创建对象数组
        类型名 * 指针名 = new 类型名[元素个数]{初值列表}; // 动态创建对象数组，同时初始化

        delete 指针名;      // 释放单个对象
        delete [] 指针名;   // 释放对象数组


    例： 
        int * p1 = new int;
        Demo * p2 = new Demo;

        int * p3 = new int(100);
        Demo * p4 = new Demo(100,200);
        Demo * p5 = new Demo{100,200};

        int * p6 = new int[5];
        Demo * p7 = new Demo[10];

        int * p8 = new int[5]{1,2,3};
        Demo * p9 = new Demo[10]{Demo(1), Demo(2)};

        delete p1;
        delete [] p6;
        delete p7;
        delete [] p9;

        问题：
        p9是一个指向对象数组的指针，释放时，没写[], 如下
        delete p9;
        会出错吗？会释放几个对象？
        编译没错，执行出错，只释放第一个对象


        问题： 
        new/delete与 malloc/free有什么区别？
        1、new/delete是运算符， 而malloc/free是 标准库函数
        2、new能自动计算所需要的内存大小，而malloc需要用户自己计算
        3、new成功返回相应类型的指针，失败抛出异常 bad_alloc, 而malloc成功返回void*, 失败返回NULL
        4、new在实例化对象时，能自动调用构造函数进行初始化，而malloc不能
        5、delete在释放对象时，能自动调用析构函数以释放资源，而free不会调用析构函数。

    空指针说明：
        传统的宏NULL，在C++依然可以使用，表示空指针
        但在某些情况下，可能会出现语法模糊的情况：
        void foo(int x) {} // 1
        void foo(int* p) {} // 2

        foo(100);   // 1
        foo(p1);    // 2
        foo(NULL); // 模糊不清

        从C++11起，引入了一个新的字面值 nullptr, 专门用来表示空指针
        nullptr不再是宏定义，它有自己的类型 nullptr_t 
        所以，当调用 foo(nullptr); 时， 精确匹配第二个foo函数。


11、字符串类型 string
    C++标准库中提供了一个string类型，专门用来描述字符串这一概念。
    使用方式：
    1、包含头文件 
        #include <string>
    2、实例化对象 
        std::string s1; // 实例化一个字符串对象，表示空字符串
        std::string s2("hello"); // 实例化一个对象，同时初始化
        std::string s2{"hello"}; // 实例化一个对象，同时初始化
        std::string s2 = "hello"; // 实例化一个对象，同时初始化
        std::string("world");   // 临时对象
        std::string s3 = s2;    // 用一个已存在的对象，初始化一个新对象
        std::string s4(10, 'a'); // "aaaaaaaaaa"

    3、常用接口
        size()      用于计算字符串中的字符个数，不包括 \0
        empty()     判断字符串是否为空，为空返回true, 否则返回false
        at()        返回给定下标的字符，如果下标越界，抛出异常 out_of_range
        c_str()     把string类型的字符串，转成 const char*
        ...
        =   +   +=   ==  !=  > >= < <=   >> <<  []


    练习：
        写一个单链表类型
        class ForwardList
        {
        private:
            struct Node // 内部类 / 嵌套类
            {
                Node(int data);
                int _data;
                struct Node* _next;
            };

            Node* _head; // 头指针
            int _size; // 元素个数 
        public:
            ForwardList();
            ~ForwardList();
            void push_front(int data);
            void pop_front();
            int front() const;
            int size() const;
            bool empty() const;
            void print() const;
            ...
        
        };


        ForwardList list; // 空的链表
        // 插入数据
        list.push_front(100);
        list.push_front(200);
        list.push_front(300);

        // 打印输出
        list.print(); // 300 200 100



12、类型转换
    C++中新增加了四种类型转换的方式
    static_cast<目标类型>(表达式)
        用于把编译器的隐式转换 显示的 表达出来
        如 int 和 char/short/double/enum 之间的转换
        如 void* 和 其他类型的指针之间的转换
        如 基类与派生类之间的转换

    reinterpret_cast<目标类型>(表达式)
        用于任意类型的指针之间的转换
        用于整数与指针之间的转换

    const_cast<目标类型>(表达式)
        用于移除引用中的const
        用于移除指向const的指针中的 const （*号左边的const）

        问题：
        const int a = 100;
        int* p = const_cast<int*>(&a);
        *p = 200; // 通过指针p修改了变量a的存储空间中的值
        cout << "a = " << a << endl; // ?100 通过变量名a读取它的值时，不会从它的存储空间中取值，使用的是编译时记录下来的那个初值。
        cout << "*p = " << *p << endl;// ?200 通过指针p获取的是存储空间中的值


    dynamic_cast<目标类型>(表达式)
        用于多态类型之间的转换(下回分解)


    作业： 
        给定一个目录，从该目录中读取它所有的位图文件名，保存到一个链表中
        遍历 文件名链表，获取每个文件名，构造图片对象，绘制到显示屏

        编写一个目录类型
        class Dir 
        {
        public:
            Dir(string path);
            ~Dir();
            ForwardList getBMP();
        private:
            ...
        };

        Dir dir("./pics");
        ForwardList list = dir.getBMP();
        for (int i = 0; i < list.size(); i++)
        {
            string filename = list.at(i);
            Bitmap bmp(filename);
            bmp.draw(s);
            sleep(3);
        }
    


13、异常 exception
    异常 是C++中的一种错误处理机制
    在编程过程中，可能会碰到两类错误：
    1、编译时错误(语法错误)
    2、运行时错误(异常)

    异常的核心思想：把错误的检测与处理分离。

    C++中的异常由以下几部分组成：
    1、抛出异常
        使用关键字 throw 来抛出异常，表示程序出现了运行错误
        语法格式：
            throw 表达式;
        例： 
        void foo(int x)
        {
            if (x < 0)
            {
                throw "error: x < 0";
            }
        }
        当程序执行了throw语句，程序流不再往下执行，而是从当前函数开始查找 异常处理语句
        如果异常没有被处理，则往上抛出，抛出给当前函数的调用者，直到被处理为止。
        如果异常是被系统所捕获，则终止当前进程。

    2、处理异常
        使用 try...catch...语句 来捕获和处理异常
        try
        {
            可能抛出异常的代码块
        }
        catch(异常类型1 形参)
        {
            处理异常1
        }
        catch(异常类型n 形参)
        {
            处理异常n
        }
        catch(...) // 表示捕获任意类型的异常
        {
            处理其他异常
        }
        如果try中的语句块 抛出了异常，则程序流从try跳转到 catch，进行异常类型匹配
            如果匹配成功，则进入异常处理
            如果匹配失败，则按顺序往下匹配
            如果所有的catch都匹配失败，则继续往上抛出，直到被处理为止。



    3、标准库中的异常类型
        C++标准库中，提供了一组异常类型，定义于头文件 <stdexcept>, 用来表示各种各样的异常情况
        常见的异常类型如下：
        std::out_of_range
        std::bad_alloc
        std::logic_error
        std::runtime_error
        ...

        这组异常类型，都有一个成员函数 what(), 返回一个const char*类型的错误信息。

    

14、拷贝构造函数 copy constructor
    拷贝构造函数用于复制(或拷贝)对象
    如果一个类的构造函数的参数是 本类类型的const引用，这种构造函数则称为拷贝构造函数(复制构造函数)
    一般如下：
    class 类名
    {
    public:
        类名(const 类名&); // 拷贝构造函数 
    };
    例：
    class Demo 
    {
    public:
        Demo();
        Demo(int x);
        Demo(const Demo& other); // 拷贝构造函数
    private:
        int x;
        int y;
    };
    如果类没有显示的定义拷贝构造函数，编译器会自动生成一个默认拷贝构造函数, 默认的实现是 按成员的声明顺序 逐成员拷贝。
    Demo d1;
    Demo d2 = d1; // d2.x = d1.x, d2.y = d1.y 

    拷贝构造函数的调用时机：
    1、直接复制一个已存在的对象，得到一个新对象
        Demo d1;
        Demo d2(d1);
        Demo d2{d1};
        Demo d2 = d1;
    
    2、把一个对象的值传递到函数中
        void foo(Demo d); // Demo d = d1;
        foo(d1);

    3、从函数返回一个对象的值
        Demo foo()
        {
            static Demo d;
            return d;
        }
        注： 如果被拷贝的对象 生命周期短暂(拷贝完成后被销毁), 编译器可能会对这种情况进行优化，省略掉拷贝构造函数的调用。

    深拷贝与浅拷贝
        如果对象占用了系统资源，在拷贝这种对象时，把对象的资源一起拷贝(或者重新分配资源)，这种拷贝过程，称为深拷贝
        如果对象占用了系统资源，在拷贝这种对象时，没有拷贝对象的资源，而是共享资源，则这种拷贝过程，称为浅拷贝

        如果对象没有占用系统资源，则一般不需要自定义拷贝构造函数，也不需要显示定义析构函数。


15、关键字 delete 和 default
    delete 关键字：
    1、用于释放new出来的动态内存
    2、用于删除编译器自动生成的某些函数(如拷贝构造函数)（C++11）
    例： 
    class Demo 
    {
    public:
        Demo(const Demo& other) = delete;
    };

    Demo d1;
    Demo d2(d1); // error 

    default 关键字：
    1、用于switch...case...语句中，表示默认情况
    2、用于要求编译器生成某些本该自动生成的函数(如默认构造函数)（C++11）
    例：
    class Demo 
    {
    public:
        Demo() = default;
        Demo(const Demo& other) = delete;
    };


1、友元 friend
    所谓友元，是指类与函数 或 类与类 之间的一种关系。
    友元授权予 某些函数或类 允许他们 直接访问本类的隐藏信息。


    友元声明
        友元函数声明
            friend 返回类型 函数名(参数列表);
            friend 返回类型 类名::函数名(参数列表);

        友元类声明：该类中所有成员函数都可直接访问当前类的隐藏信息
            friend class 类名;

    例： 
    class Demo 
    {
    public:
        friend void print_demo(Demo d); // 全局函数友元声明
    private:
        int x;
    };

    void print_demo(Demo d) 
    {
        cout << d.x << endl;
    }

    说明： 
    1、友元声明可出现在类中的任意位置
    2、在友元声明处 可直接定义该函数，但它不是类的成员函数(也不建议这么做)
    3、友元关系是单向的、友元关系是不可传递的。
    4、同类型的对象，互为友元。



2、运算符重载
    所谓的运算符重载，就是给已有运算符添加新功能, 使得这些运算符 能适用于 类类型的对象。
    在C++中，运算符是用 函数实现的，所以，运算符重载的本质，就是函数重载。

    运算符与运算符函数的对应关系：
    1、运算符号 对应 函数名 
        运算符函数的名称 由 关键字 operator 加上 运算符号 组成
            例： 
            + 对应的函数名 operator+
            < 对应的函数名 operator<
    2、操作数 对应 函数参数
    3、运算结果 对应 函数的返回值
    4、运算符过程 对应 函数体 

    当运算符函数编写完成，一般是由编译器自动调用，也可以像普通函数一样的直接调用。

3、双目运算符
    典型的双目运算符，如 + - * /  == != > >= < <=
    重载的方式有两种：
    1、可以重载为全局函数，一般需要做友元声明，此时，运算符函数有两个参数
    2、可以重载为类的非静态成员函数，不需要友元声明，此时，运算符函数只有一个参数(左操作对象用于调用运算符函数，右操作对象作为参数)


    输入输出运算符 >>  <<  
        IO流对象(cout/cin/cerr等)，不支持拷贝
        所以，在传参和返回时，只能使用它们的引用。
        输入输出运算符 只能重载为 全局函数。

        输出运算符的一般形式
            ostream& operator<<(ostream& out, 类名 对象名);
            或
            ostream& operator<<(ostream& out, const 类名& 引用名);

        输入运算符的一般形式
            istream& operator>>(istream& in, 类名& 引用名);


    (拷贝)赋值运算符
        对象的拷贝分两种：
        拷贝构造函数，用一个已存在的对象，初始化一个新对象
        拷贝赋值运算符，用一个已存在的对象，给另一个已存在的对象赋值
        例：
        Demo d1;
        Demo d2 = d1;   // 拷贝构造 
        d2 = d1;        // 拷贝赋值 

        如果一个类中没有显示的定义拷贝赋值运算符函数，编译器会自动生成(浅拷贝).
        如果对象占用了系统资源，自动生成的赋值运算符 就可能出错，此时，需要自己控制对象的拷贝过程。

        赋值运算符函数 只能 重载为 类的非静态成员函数。
        一般如下： 
        class 类名 
        {
        public:
            类名& operator=(const 类名& other);
        };



4、单目运算符
    自增运算符++ 可以重载为 全局函数，也可以重载为 类的非静态成员函数。
    前++的一般形式：
        类名& operator++(类名& 引用名); // 全局函数 
        类名& operator++();             // 类的非静态成员函数。

    后++的一般形式：
        类名 operator++(类名& 引用名, int); // 全局函数 
        类名 operator++(int);               // 类的非静态成员函数。

    说明： 
        后++函数中的int,称为占位符参数，只占位置，不参与运算，用于区分前后++
        --与++类似。

5、特殊运算符    
    [] 下标运算符  只读重载为类的非静态成员函数，可能有两个版本
        例： 
        class Demo
        {
        public:
            Demo()
            {
                p = new int[10]{1,2,3,4,5};
            }
            int& operator[](int index)  // Demo* const this
            {
                return p[index];
            }
            const int& operator[](int index) const // const Demo* const this
            {
                return p[index];
            }
        private:
            int* p;
        };
        
    () 函数调用运算符
        如果一个类重载了 函数调用运算符，则这种类型的对象，可称之为 函数对象(仿函数)。
        函数对象的行为 类似于函数，可以调用！
        例： 
        class Demo 
        {
        public:
            void operator()()
            {

            }
            void operator()(int x)
            {

            }
            void operator()(int x, int y)
            {

            }
        };

        Demo d;
        d();
        d(100);
        d(100,200);


作业：
    写一个字符串类型 
    class string
    {
    public:
        string(const char*s = NULL);
        ~string();
        string(const string&);
        赋值运算符
        输出运算符 

        元素个数
        判断空
        +
        +=
        ==
        > 
        <
        []
        at
    private:
        char* _data;
    };


6、lambda 表达式
    lambda 表达式 表示的是一段可调用的代码单元，本质上是一个函数对象，称为 匿名函数。
    语法格式：
    [捕获列表](参数列表)->返回类型{函数体}
    说明：
        参数列表 
            与普通函数的参数列表类似，但它不能设置默认值，如果不需要传参，可以空着，也可以省略()
        返回类型
            与普通函数的返回类型，通常省略不写，由函数体中的return表达式来自动推导
            如果自动推导出来的类型与期望的不致，则手动显示指定即可。

        函数体 
            可以为空，但大括号不能省略。

        捕获列表
            一般来说，lambda表达式出现在某个函数内部，函数中可能有局部变量
            如果 lambda表达式的函数体 需要使用 该表达式所在函数中的 局部变量, 则需要在[]中进行说明，这就是所谓的捕获列表
            如果需要捕获局部变量的值，在[]中写变量名即可，也可以用 '=' 来代表捕获所有局部变量的值
            如果需要捕获局部变量的引用，在[]中写 &变量名即可，也可以用 '&' 来代表捕获所有局部变量的引用

    例： 
    void foo()
    {
        int a = 0;
        [&]{
            a++;
            cout << "a = " << a << endl;
        };
    }

    auto关键字说明：
    在C++11之前，它的功能和C语言中的auto一样, 表示自动变量，用于修饰局部变量。
    从C++11起，它不再表示自动变量了，而是用来 根据对象的值 自动推导对象的 类型。 
    例： 
    auto a = 1;
    auto b = 1.2;

    练习：
    给定一个整型数组，写一个算法，查找第一个满足条件的元素，返回其下标
    例： 
    int a[5] = {1,2,3,4,5};
    int index = find_if(a, 5, ...); // 第一个3的倍数，index==2
        


7、关键字 explicit
    explicit 关键字 用于防止编译器 使用构造函数或类型转换运算符 做隐式类型转换。
    例： 
    class Demo 
    {
    public:
        Demo(int x) {}
    };

    Demo d1(100);
    Demo d2 = 200; // Demo d2 = Demo(200);


    类型转换运算符
        类型转换运算符 是一种特殊的成员函数，负责将一个类类型的对象 转换成其他的类型
        一般如下：
        operator 类型名() const ;
        说明： 
            这种函数不需要写返回类型，operator后面的类型名就是返回类型
            参数列表必须为空，同时应该加上const
            这种函数只能是非静态的成员函数。

    例： 
    class Demo
    {
    public:
        // 构造函数
        explicit Demo(int x) : x(x)
        {
            cout << "Demo(int)" << endl;
        }
        // 类型转换运算符
        explicit operator int() const
        {
            return x;
        }
    private:
        int x;
    };    

    Demo d = 100; // error



8、对象的移动(c++11)
    对象的移动和对象的拷贝类似，也分两种：
    移动构造
    移动赋值

    C++11标准增加了对象的移动操作，用于移动对象的资源。
    当使用移动操作 把一个对象的资源 转移 给另一个对象后，原对象就不再拥有资源。

    为了实现移动操作，C++11引入了 右值引用。
    右值引用：只能绑定到右值的引用
    一般如下：
    类型名 && 引用名 = 右值;

    如果一个构造函数的参数是 本类类型的右值引用，则称为移动构造函数
    如果一个赋值运算符函数的参数是 本类类型的右值引用， 则称为 移动赋值运算符。

    例：
    class Demo 
    {
    public:
        Demo()
        {
            p = new char[100];
        }

        Demo(Demo&& other); // 移动构造
        Demo& operator=(Demo&& other); // 移动赋值 

        ~Demo()
        {
            delete [] p;
        }
    private:
        char* p;
    };
    一般情况下，只有参数是右值引用时，才能触发移动操作。
    所以， C++标准库中提供了一个专门的函数move, 用于获取给定对象的右值引用。

    例： 
    Demo d1;
    Demo d2 = std::move(d1);// 调用移动构造函数

    对象移动的典型示例：
    void swap(String& s1, String& s2)
    {
        String t = std::move(s1);
        s1 = std::move(s2);
        s2 = std::move(t);
    }



9、三个结论
    1、只能重载已有运算符，不能创造新的运算符
    
    2、有些运算符 不能 重载，比如：
        .   ?:  ::  sizeof    .*

    3、有些运算符 只能重载为 类的非静态成员函数，比如：
        =   []  ()  ->

    

1、继承
    所谓继承，指的是在已有类的基础上 创建新的类型，新的类型会继承(获取)原有类所有的特征(扩展已有类型)。
    继承能够实现代码复用、减少代码冗余、提高开发效率。
    继承主要用于描述那些非常相似 但有细微差别的 类型之间的关系(is-a的关系)。

    例：
        计算机  
            台式机、笔记本、平板、手机
        
        学生
            大学生、中学生、小学生

        车
            公交车、洒水车、小汽车、电动车

    用于描述共性的类型，称为 基础类(Base Class)，简称基类，也叫父类，如上述示例中的 计算机、学生、车
    在基类的基础上创建出来的新类型，称为 派生类(Derived Class), 也叫子类，如上述示例中的 笔记本、大学生、公交车

    C++中继承语法如下：
    class 派生类名: 继承方式 基类名1, ..., 继承方式 基类名n
    {
        派生类新增加的成员
    };
    根据基类的个数，继承可分为：
    单(一)继承：只有一个基类
    多(重)继承：两个或两个以上的基类

    继承方式：决定了基类中的成员，在派生类内部和外部 的访问权限，分三种：
    public      公有继承
    private     私有继承
    protected   保护继承

    说明：
    继承方式可省略，如果省略，则
        class默认的继承方式为 private
        struct默认的继承方式为 public


    继承方式说明：
    public公有继承
        基类的公有成员，通过公有继承，成为派生类的公有成员(即在派生类内部和外部都可直接访问)
        基类的私有成员，通过公有继承，成为派生类的不可访问的成员(即在派生类内部和外部都不可直接访问)
        基类的保护成员，通过公有继承，成为派生类的保护成员(即在派生类内部可直接访问，外部不能直接访问，友元可直接访问、后代可直接访问)

    private私有继承
        基类的公有成员，通过私有继承，成为派生类的私有成员(即在派生类内部可直接访问，外部不能直接访问，友元可直接访问)
        基类的私有成员，通过私有继承，成为派生类的不可访问的成员(即在派生类内部和外部都不可直接访问)
        基类的保护成员，通过私有继承，成为派生类的私有成员(即在派生类内部可直接访问，外部不能直接访问，友元可直接访问)

    protected保护继承
        基类的公有成员，通过保护继承，成为派生类的保护成员(即在派生类内部可直接访问，外部不能直接访问，友元可直接访问、后代可直接访问)
        基类的私有成员，通过保护继承，成为派生类的不可访问的成员(即在派生类内部和外部都不可直接访问)
        基类的保护成员，通过保护继承，成为派生类的保护成员(即在派生类内部可直接访问，外部不能直接访问，友元可直接访问、后代可直接访问)


2、继承中的构造与析构
    构造函数与析构函数 是不能继承的
    如果基类有默认构造函数，当实例化派生类对象时，会先自动调用基类的构造函数，再调用派生类自己的构造函数
    如果基类没有默认构造函数，或需要调用基类其他带参数的构造函数，则
        派生类必须定义构造函数，且在构造函数的初始化列表中 显示的 调用基类的构造函数 才能初始化从基类继承来的成员。
    例： 
    class Derived: public Base 
    {
    public:
        Derived(int a, int b, int c): Base(a,b,c)
        {
            cout << "Derived(int,int,int)" << endl;
        }
    };    


    练习： 
        派生类如果增加了成员对象，则成员对象的构造函数与析构函数在什么时候调用？
    说明：
    当实例化一个派生类对象时，可能会涉及三种构造函数与析构函数：
        基类的构造函数、成员函数的构造函数、派生类的构造函数
        析构函数的调用与此相反。
    与对象的资源控制相关的函数，都不继承。


3、继承中的同名成员
    派生类可以在基类的基础上增加新的成员，这些新的成员可以与基类的成员 同名(因为作用域不同)。
    如果派生类中定义的函数与基类中的某个函数同名，会出现 函数隐藏 的效果。
    函数隐藏：
    当用派生类对象 调用这种同名函数时，默认调用的是 派生类新增加的那个函数
    而基类的同名函数，被隐藏了。
    函数隐藏只与函数名相关，与返回类型及参数列表无关。

    如果需要显示的调用那些被隐藏的成员，只需要指明作用域即可。
    例： 
    class Base
    {
    public:
        void print() const 
        {
            cout << "x = " << this->_x << endl;
        }
    };

    class Derived: public Base
    {
    public:        
        int print(int y=1) const // 与基类函数同名
        {
            cout << "y = " << _y << endl;
            return 0;
        }
    };    

    Derived d;
    d.print();  // 调用的派生类新增加的print函数
    d.Base::print();// 通过指定作用域调用基类的同名函数


4、is-a关系具体表现
    公有派生类与它的基类，存在着 "是一个"（is-a）的关系
    在程序中，具体表现如下：
    1、可以用公有派生类对象 初始化 基类对象 
        Derived d1;
        Base b1 = d1;

    2、可以用公有派生类对象 给基类对象 赋值
        b1 = d1;

    3、基类指针 可以指向 任意的公有派生类对象
        Base* p = &d1;

    4、基类引用 可以 绑定到 任意的公有派生类对象
        Base& r = d1;


    问题：
        基类指针 可以指向公有派生类对象，能不能通过指针 去访问派生类新增加的成员？
        通过基类指针 无法直接访问派生类新增加的成员
        如果确实需要，访问派生类新增加的成员，那么使用 static_cast 做类型转换即可（把基类指针转成派生类指针）
    



5、多重继承 
    所谓多重继承，指一个派生类有两个或两个以上基类的情况，派生类会继承它所有基类的特征。
    例： 
    class Base1 {};
    class Base2 {};
    class Derived: public Base1, public Base2 {}

    多重继承中的二义性问题：
    例： 
    class Base1 {
    public:
        void foo() {}
    };
    class Base2 {
        void foo() {}
    };
    class Derived: public Base1, public Base2 {};

    Derived d;
    d.foo(); // 编译错误
    解决方案：
    1、指定作用域
        d.Base1::foo();
    2、隐藏基类的同名函数


    多重继承中的"菱形继承"("钻石继承")
    例： 
    class A {};
    class B: public A {};
    class C: public A {};
    class D: public B, public C {};

    菱形继承中存在的问题：
        最顶层A类中的成员，通过多条继承路径，到达最底层的D类中时，会出现多份拷贝且被初始化多次

    解决方案：使用虚继承
        在菱形继承中， B类和C类在继承A类时，在继承方式的前面(或后面)加上一个关键字 virtual ,这种继承就被称为 虚继承。
        虚继承 能保证虚继承A中的成员，在派生类D中，只保留一份(B和C共享A的成员)，且只初始化一次(由D类调用A的构造函数)
    例：
    class A {}; // 虚基类 
    class B: virtual public A {}; // 虚继承 
    class C: virtual public A {}; // 虚继承
    class D: public B, public C {};

    说明： 
        虚继承 会付出一定的代价：只要使用了虚继承，该类的对象中就会多出一个指针(虚基类指针)
        在计算D类对象大小时，需要考虑这些自动生成的虚指针 及 字节对齐。



6、多态
    所谓多态，指不同的对象，收到相同的消息，产生不同的行为。
    说明： 
        不同的对象，一般是指同一类族中的 不同类型的对象
        相同的消息，指调用这些不同对象的 相同的 成员函数
        不同的行为，指这些相同的函数定义不同。

    例： 
    class A {
        virtual void foo();
    };
    class B : public A {};
    class C : public A {};

    void bar(A* p)
    {
        p->foo(); // 如果p指向不同的对象，就输出不同的数据，这种效果就是多态
    }

    bar(new B);
    bar(new C);

    多态能实现接口重用，能通过统一的接口处理不同类型的对象
    多态能在一定程度上 忽略那些相似类型之间的差异，以统一的方式进行处理。


    C++中的多态一般分两种：
    编译时多态(静态多态、静态联编、静态绑定)
        当调用某个函数时，在编译阶段能确定 具体要调用的是哪个函数
        实现方式：函数重载、运算符重载

    运行时多态(动态多态、动态联编、动态绑定)
        当调用某个函数时，在编译阶段无法确定 具体要调用的是哪个函数，只有在程序运行时，才能确定下来
        实现方式： 虚函数 


7、虚函数
    用关键字 virtual 说明的 函数，称为 虚函数 
    一般格式
    class 类名 
    {
    public:
        virtual 返回类型 函数名(参数列表); // virtual 只需要在声明时添加即可。
    };

    如果一个函数被说明为 虚函数，则表示允许(希望)它的派生类重新定义该函数。
    如果派生类需要重新定义基类的某个虚函数，则要求这个重新定义的函数原型(返回类型、函数名、参数列表)与基类的虚函数原型 完全一致。
    (注：只读成员函数后面的那个const也是参数列表的一部分)
    这种派生类重新定义的函数，即使不加关键字 virtual,它自动的就是虚函数。
    这种在派生类中重新定义基类某个虚函数的行为，称为 函数重写(或函数覆盖) // 考点：函数重载、函数隐藏、函数重写

    当用基类指针或基类引用 调用这种虚函数时，就会发生动态绑定。

    例： 
    class A {
        virtual void foo(){}
    };
    class B : public A {
        void foo(){}
    };
    class C : public A {
        void foo(){}
    };

    void bar(A* p)
    {
        p->foo(); // 如果p指向B类对象，则调用B中的foo函数，如果p指向C类对象，则调用C中的foo函数，这就是动态绑定
    }

    bar(new B);
    bar(new C);

    练习： 
        写一个形状类Shape, 以它为基类，派生 矩形和圆形
        用多态的方式，计算矩形和圆形的周长与面积
        提示：
        class Shape {};
        class Rect: public Shape {};
        class Circle: public Shape {};

        void foo(Shape* p)
        {
            p->area(); // p指向矩形，则计算矩形的面积，p指向圆，则计算圆的面积
        }
        foo(new Rect(100,200));
        foo(new Circle(10));



8、纯虚函数与抽象类
    在设计基类时，有些虚函数仅表示 该类型 应该具有某种功能，但该功能的具体实现 应该由不同的派生类来完成。
    这种函数，一般会设计成纯虚函数。
    一般如下：
        virtual 返回类型 函数名(参数列表) = 0;      

    纯虚函数用于规范接口，而不提供具体实现。
    如果一个类中包含 纯虚函数，则这种类型，称为 抽象类。
    抽象类 无法实例化对象。  



9、关键字 overried 与 final （c++11）  
    overried 用于说明派生类中的某个函数是 虚函数，且是重写(或覆盖)了基类的虚函数
    同时，编译器会对这种函数进行语法检查，如果不满足重写的规则，会给出错误提示
    例： 
    class Base 
    {
    public:
        virtual void foo() {}
    };
    class Derived: public Base
    {
    public:
        void foo() overried {}
    };

    final 可以修饰虚函数，也可以修饰类型
        修饰虚函数时，表示 该函数 不能被重写
        修饰类型时，表示该类型不能继承


10、虚函数中的默认值
    一般的虚函数可以重载、可以设置默认值。
    如果基类的虚函数设置了默认值，派生类重写的虚函数 可以不设置默认值，也可以设置不一样的默认值。
    当用基类指针或引用 调用这种虚函数时，发生动态绑定时，使用的是基类设置的默认值。
    例： 
    class Base 
    {
    public:
        virtual void foo(int x = 1)
        {
            cout << "Base.x = " << x << endl;
        }
    };
    class Derived: public Base 
    {
    public:
        void foo(int x=2) override // 派生类重写的虚函数设置了不一样的默认值
        {
            cout << "Derived.x = " << x << endl;
        }
    };    

    void bar(Base* p)
    {
        p->foo(); // 不管p指向的是基类对象还是派生类对象，默认值在编译器阶段确定，都是1
    }



11、虚析构函数
    有些函数是不能用 virtual 说明的，比如，全局函数、友元函数、静态函数、构造函数
    但析构函数可以。

    正常情况下，派生类对象销毁时，会依次调用 派生类的析构函数、成员对象的析构函数、基类的析构函数
    但是，如果是用基类指针 指向 new出来的派生类对象，当用delete释放这种对象时
        默认情况下，只会调用基类的析构函数，而不会调用其他的析构函数，从而可能造成 资源泄漏。

    解决方案：
        把基类的析构函数 说明为 虚函数，然后它所有派生类的析构函数 自动成为 虚函数。
        当用delete释放这种 由基类指针指向的动态对象时，就不会再造成资源泄漏。    
    
    说明： 
        如果是基类，则其析构函数应该说明为虚函数。

    问题：
        在构造函数与析构函数中，如果调用 虚函数，会不会发生动态绑定？
        在构造函数与析构函数中调用 虚函数，不会发生动态绑定。
    class Base 
    {
    public:
        Base()
        {
            foo();
        }
        virtual void foo() {}
    };
    class Derived: public Base 
    {
    public:
        Derived()
        {
            foo();
        }
        void foo() override {}
    };
    Base* p = new Derived;





12、动态类型转换 dynamic_cast
    dynamic_cast 用于多态类型之间的 向下类型转换(向下转型)
    说明： 
        多态(polymorphic)类型: 包含有虚函数的类型
        向下类型转换：把基类指针或引用 转换成 派生类指针或引用

    dynamic_cast 在类型转换时， 会进行 运行时类型识别，如果类型一致，则返回对象的地址，如果类型不一致，则转换失败
        如果是指针，失败时，返回空指针 nullptr
        如果是引用，失败时，抛出异常。
    所以在使用 dynamic_cast时，需要判断其是否转换成功。
    例： 
    class Base {};
    class Derived1: public Base {};
    class Derived2: public Base {};

    Base *p = new Derived1;
    Derived1 * p1 = dynamic_cast<Derived1*>(p);
    if (p1 != nullptr)
    {
        // 转换成功，就可以通过p1访问派生类新增加的成员
    }

    Derived2 * p2 = dynamic_cast<Derived2*>(p); // 转换失败，返回nullptr
    


13、虚函数的调用过程(实现原理)
    如果一个类中包含有虚函数，编译器在编译时，会为该类型 维护一个 虚函数表(vtable，可理解为一个数组)
    虚函数表中记录了 该类中所有虚函数的地址
    在编译基础指针或引用 调用虚函数的 代码时，会把虚函数的调用，转换成 在虚函数表中 该虚函数所对应的索引(下标)
    例： 
    class Base 
    {
    public:
        virtual void foo() {}
        virtual void bar() {}
    };
    编译器自动创建一个虚函数表：
        该表中第一个元素就是foo函数的地址，索引下标为0
        该表中第二个元素就是bar函数的地址，索引下标为1

    void f(Base* p)
    {
        p->foo(); // 编译时，此处记录的不是foo函数的地址，而是它在虚函数表中的索引下标
    }

    当实例化一个对象时，编译器会自动把该类型的虚函数表的地址(vptr)插入到对象的存储空间中(一般插入到最前面)
    当用基类指针或引用，执行虚函数的调用时：
        先从对象空间中 找到 虚指针(虚函数表的地址)
        然后根据编译时记录下来的索引下标，从虚函数表中 获取虚函数的地址(即函数指针)
        最后，通过函数指针调用 虚函数。


    当一个类继承这种带有虚函数的类时，派生类也会生成一个虚函数表，该表中依次存储的是：
    1、从基类继承来的虚函数的地址
    2、派生类新增加的虚函数的地址
    注：如果派生类重写了基类的某个虚函数，则会覆盖虚函数表中 基类虚函数的地址

    例： 
    class Derived: public Base 
    {
    public:
        void bar() override {}
        virtual void show() {}
    };
    派生类虚函数表中存储的是：
        &Base::foo 
        &Derived::bar 
        &Derived::show 




泛型编程
    所谓泛型编程，就是指独立于某些特定类型的编程，使得同一份代码适用于多种数据类型，从而提高代码重用性和灵活性。

    在C++中，使用模板来实现泛型编程。


模板 template
    模板用于描述那些通用的行为或概念。
    根据描述的对象不同，模板可分为：
    函数模板
    类模板    


函数模板 
    函数模板不是函数，而是用来生成函数的一种模板(机制)    
    一般格式：
    template<typename T1, ..., typename Tn>
    返回类型 函数名(参数列表)
    {
        函数体
    }
    例：
    template<typename T>
    void swap(T&a, T& b)
    {
        T tmp = a;
        a = b;
        b = tmp;
    }

    int a = 1;
    int b = 2;
    swap(a, b);=> 根据实参的值，推导出模板参数的类型为int, 生成具体的函数 void swap(int&,int&), 再调用这个具体生成的函数

    练习：
        用函数模板实现常规算法
            交换、比较、查找、最值
            swap 
            compare
                比较两个对象，
                    第一个比第二个小，则返回-1
                    第一个比第二个大，则返回1
                    相等，返回0
            find
                从一个任意类型的数组中，查找特定的值，找到则返回其下标，否则返回-1
            max
            min

    说明：
    1、模板声明中的 typename 用于说明其后的标识符，是一个类型的名字，也可以使用关键字 class
    2、一般情况下，编译器能根据实参自动推导模板参数的具体类型
        但，如果编译器无法根据实参推导出所有的模板参数，或推导出来的模板参数与期望的不一致
        此时，需要显示的指定模板函数类型，如下：
        函数模板名<模板参数列表>(实参列表)
        例： 
        template<class T>
        T max(T a, T b)
        {
            return a > b ?a : b;
        }
        max(a, b)   // 自动推导
        max<int>(a,b)// 显示指定

    3、模板的声明与定义如果分开，则在声明与定义时都需要添加模板声明
        且，模板的声明与定义必须出现在同一个编译单元中。
        所以，一般的做法是把模板写在头文件中，且声明与定义一般不分开。


    4、模板特化
        模板特化是 通用模板的一种特殊情况,  一般如下：
        template<>
        返回类型 函数名(参数列表)
        {
            函数体 
        }
        模板的特化版本，必须出现在通过版本的后面。
        例： 
        template <typename T> // 通过版本
        int mycompare(T a, T b)
        {
            if (b < a)
                return 1;

            if (a < b)
                return -1;

            return 0;
        }

        template <> // 特别版本
        int mycompare(const char *a, const char *b)
        {
            if (strcmp(a, b) > 0)
                return 1;

            if (strcmp(a, b) < 0)
                return -1;

            return 0;
        }        



类模板
    类模板不是类，而是用来生成类的一种机制
    一般格式：
    template<typename T1, ..., typename Tn>
    class 类名
    {
    public:
        公有方法
    private:
        私有数据/方法
    };

    说明： 
        使用类模板时，必须显示的指定模板参数

        当用类模板实例化对象时，是编译器自动使用模板生成类型，再用类型实例化对象
            模板类名<模板参数列表> 对象名;

        类模板的成员函数声明与定义如果分开，则它们必须出现在同一个编译单元中，且在类外定义成员函数时，必需要添加模板声明。

    例：
    template<typename T>
    class SeqStack
    {
    public:
        SeqStack(int n);
        ~SeqStack();
        void push(T data);
        void pop();
        T top() const;
        bool empty() const;
    private:
        T* _data;
        int _top;
        int _max;
    };

    SeqStack<int> stack1(10);
    stack1.push(1);
    stack1.push(2);
    stack1.push(3);
    while (!stack1.empty())
    {
        cout << stack1.top() << endl;
        stack1.pop();
    }
    SeqStack<std::string> stack2(5);



    练习： 
    用类模板实现一个动态数组

    template<typename T>
    class Vector
    {
    public:
        Vector();
        ~Vector();
        void push_back(T data); // 插入数据时，如果容量不足，则扩容
        void pop_back();
        T back() const;
        int size() const;
        bool empty() const;
        int capacity() const;
        T at(int index) const;
        operator[]
        operator<<

        拷贝构造
        拷贝赋值
        移动构造
        移动赋值
    private:
        T* _data;
        int _size; // 当前元素的个数
        int _capacity;// 最多能存放多少个元素
    };

    Vector<int> a;
    a.push_back(1);
    a.push_back(2);
    for (int i = 0; i < a.size(); i++)
    {
        cout << a.at(i) << endl;
    }
    cout << a << endl;




标准模板库 Standard Template Library - STL
    STL是标准库的重要组成部分，由以下几部分组成
    容器、算法、迭代器、函数对象






